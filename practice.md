# Практические задания

## Задание 1: Простой тест авторизации

Выполнить задание ниже используя теорию "Основные методы Selenium WebDriver в Python"
Весь код пока пишем одним файлом, без классов, функций, фикстур, просто дописать шаблон
Для написания локаторов в целях обучения попробовать разные методы, By.ID, By.XPATH и т.п.

1. Установить браузер chrome (обычный, вебдрайвер селениум сам подтянет)
2. Установить pycharm, создать проект, создать файл `test_login.py`, вставить в файл шаблон решения представленный ниже
3. Установить selenium через наведение мыши в IDE на строках импорта (from selenium import webdriver)
4. Комментарии "# 1." оставляем, требуемый код дописываем ниже каждого комментария
5. Для проверки текста использовать assert. Есть ньюанс с проверкой текста, добиться именно успешного прохождения, считаем что не баг, а особенность.

Практическое задание

Задача: Автоматизировать сценарий:

1. Открыть https://the-internet.herokuapp.com/login
2. Ввести логин tomsmith и пароль SuperSecretPassword!
3. Нажать Login
4. Дождаться сообщения "You logged into a secure area!"
5. Нажать Logout

Шаблон решения:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome()
try:
    driver.get("https://the-internet.herokuapp.com/login")
    
    # Ваш код здесь
    # 1. Найти поля ввода и кнопку
    # 2. Ввести учетные данные
    # 3. Кликнуть Login
    # 4. Ожидать появления flash-сообщения (id="flash")
    # 5. Проверить текст сообщения
    # 6. Найти и нажать Logout
    
finally:
    driver.quit()
```

## Задание 2: Добавление в проект pytest

Добавим в начало файла

```python
import pytest
```

Вынесем написанный нами код (все кроме импортов) в функцию и добавим класс

Важно!

- Имена тестовых классов - Должны начинаться с Test (с большой буквы)
- Имена тестовых функций - Должны начинаться с test_

Добавьте любую pytest метку для теста

в результате должно получиться так:

```python
class TestLoginPage:

    @pytest.mark.smoke
    def test_login(self):
        driver = webdriver.Chrome()
        try:
# остальной код без изменений не считая отступов
```

Написать по аналогии второй тест, пока отдельной функцией `def test_login_invalid(self):`
Тест на ввод неправильного логина с проверкой сообщения "Your username is invalid!"

Проверьте что у обоих тестов указана одна и та-же метка `@pytest.mark.smoke`

Создайте файл `pytest.ini` в корне проекта и скопируйте в него следующее:

```
[pytest]

# Указывается шаблон имен файлов для обнаружения тестов
python_files =
    test_*.py
 
# Указывается шаблон имен для обнаружения тест-классов
python_classes = Test*

# Указывается шаблон имен для обнаружения тест-методов
python_functions = test_*

# Добавление меток (например, для запуска тестов с определёнными метками)
markers =
    regress: метки для регресс тестов
    smoke: метки для smoke-тестов

# Указывает на директорию для хранения временных файлов
cache_dir = .pytest_cache

# Игнорировать эти директории при поиске тестов
norecursedirs = .git venv
```

Запустите тесты через терминал в pycharm командой:
```
pytest -m smoke
```

## Задание 3: Вынос переменных и локаторов элементов из тестов

Теперь когда у нас два теста использующих одни и те-же переменные и локаторы элементов вынесем их из тестов. Вынесем только то, что обозначено ниже:

```python
class TestLoginPage:
    # Конфигурационные параметры
    BASE_URL = "https://the-internet.herokuapp.com/login"
    WAIT_TIMEOUT = 15

    # Локаторы элементов
    class Locators:
        USERNAME_INPUT = (By.ID, "username")
        PASSWORD_INPUT =
        LOGIN_BUTTON =
        FLASH_MESSAGE = 
        LOGOUT_BUTTON = 

    # Текстовые константы
    class Messages:
        SUCCESS_LOGIN = "You logged into a secure area!"
        INVALID_USERNAME = "Your username is invalid!"
```
В коде самих тестов заменить прямое использование на переменные. 


В случаях с обычными переменными все просто, мы заменяем значение в тесте на переменную через self

```python
driver.get(self.BASE_URL)
```
Если переменная добавлена в класс:

```python
self.класс.переменная
```

С локаторами немного сложнее:

```python
username = driver.find_element(*self.Locators.USERNAME_INPUT)
```
Звездочка * в Python используется для распаковки кортежа (tuple unpacking).

В нашем случае:

```python
username = driver.find_element(*self.Locators.USERNAME_INPUT)
```
Эквивалентно:

```python
username = driver.find_element(By.ID, "username")
```
Почему это нужно:

- Локатор хранится как кортеж: USERNAME_INPUT = (By.ID, "username")
- Метод find_element ожидает два отдельных аргумента: find_element(by, value)
- Распаковка преобразует: *(By.ID, "username") → By.ID, "username"

## Задание 4: Добавление в проект параметризации

Хоть мы и вынсли переменные из тестов - дублирования кода остается много. 
Видно что мы получили два теста с одинаковой логикой, большая часть кода в которых совпадает, частично уйти от этого нам поможет параметризация.

Следующий шаг обьединить эти два теста в один.

Доработаем тест test_login

1. Добавить в функцию на вход три параметра 

```python
def "test_login(self, login, password, expected_result):"
```

через `expected_result` мы будем определять что мы ожидаем - сообщение об успехе или ошибку

2. Изменить в "2. Ввести учетные данные" ввод не конкретных значений а переменные login, password
3. Добавить перед обьявлением функции параметризацию

```python
    @pytest.mark.parametrize("login, passwd, expected_result",
        [
            ("tomsmith", "SuperSecretPassword!", True), # Валидные данные
            (), # Неправильный пароль
        ]
    )
```

1. Сначала мы обозначаем какие переменные мы будем передавать `"login, passwd, expected_result"`
2. Затем перечисляем конкретные значения этих переменных `"tomsmith", "SuperSecretPassword!", True`

Рассмотрим только эти два кейса:
1. Валидные данные
2. Неправильный логин

ps: Тут есть еще вариант с неправильным паролем и правильным логином, но на нормальных ресурсах не делают отдельное сообщение для таких ситуаций и для этого нужно немного менять подход к параметризации. 

Что бы выполнять один из двух assert'ов можно использовать "if expected_result:" более наглядно это можно представить как "if expected_result == True:" просто более правильное и лаконичное написание

Не забудте учесть что кнопки Logout без успешной авторизации не будет

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options


class TestLoginPage:

    def configure_chrome_driver(self):
        chrome_options = Options()

        # Настройки для отключения сохранения паролей и автозаполнения
        prefs = {
            "credentials_enable_service": False,
            "profile.password_manager_enabled": False,
            "profile.default_content_setting_values.notifications": 1  # Пример: блокировка уведомлений
        }
        chrome_options.add_experimental_option("prefs", prefs)

        driver = webdriver.Chrome(options=chrome_options)
        return driver

    @pytest.mark.smoke
    @pytest.mark.parametrize("login, passwd, expected_result",
        [
            ("tomsmith", "SuperSecretPassword!", True), # Валидные данные
            ("login", "password", False), # Неправильный пароль
        ])
    def test_login(self, login, passwd, expected_result):

        driver = self.configure_chrome_driver()
        try:
            driver.get("https://the-internet.herokuapp.com/login")

            # 1. Найти поля ввода и кнопку
            username = driver.find_element(By.ID, "username")
            password = driver.find_element(By.ID, "password")
            login_button = driver.find_element(By.TAG_NAME, "button")

            # 2. Ввести учетные данные
            username.send_keys(login)
            password.send_keys(passwd)

            # 3. Кликнуть Login
            login_button.click()

            # 4. Ожидать появления flash-сообщения (id="flash")
            wait = WebDriverWait(driver, 15)
            message = wait.until(EC.visibility_of_element_located((By.ID, "flash")))

            # 5. Проверить текст сообщения
            message_clear = ' '.join(message.text.strip().replace('×', '').split())
            if expected_result:
                assert message_clear == "You logged into a secure area!", f'Expected "You logged into a secure area!", got "{message_clear}"'

                # 6. Найти и нажать Logout
                logout_button = driver.find_element(By.LINK_TEXT, "Logout")
                logout_button.click()
            else:
                assert message_clear == "Your username is invalid!", f'Expected "Your username is invalid!", got "{message_clear}"'


        finally:
            driver.quit()
```

## Задание 5: Добавление в проект фикстуры

Мы можем вынести инициализацию и закрытие браузера в фикстуру, используя pytest.
Создадим фикстуру, которая будет запускать браузер перед каждым тестом и закрывать после.

Создадим фикстуру driver до обьявления класса

```python
@pytest.fixture
def driver():
    # открыть браузер
    # перейти на страницу
    yield
    # закрыть браузер после завершения теста
```

В итоге должно получиться так:

```python
@pytest.fixture
def driver():
    driver = webdriver.Chrome()
    driver.get("https://the-internet.herokuapp.com/login")
    yield
    driver.quit()
```

и теперь нашим тестам нужно сообщить о существовании `driver`

```python
def test_login(self, driver):
```

Убедитесь что убрали из тестов все что связано с браузером, т.е. то что описано в фикстуре `driver`
Весь код фикстуры до `yield` выполнится перед выполнением кода каждого теста
Весь код фикстуры после `yield` выполнится после выполнения кода каждого теста

## Задание 6: Изменение структуры проекта по Page Object

Cоздайте файл login_page.py

В нем создадим класс LoginPage

Вынесем конфигурационные параметры и локаторы элементов из test_login.py в login_page.py

Фикстуру и BASE_URL пока оставляем в test_login.py

В login_page.py создадим функцию login
В нее нужно переместить все что находится в функции test_login

переместить часть импортов в login_page.py

```python
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
```

В файл test_login.py импортируем класс LoginPage из login_page

```python
from login_page import LoginPage
```
И вызовем функцию login в тесте

```python
page = LoginPage()
page.login(driver, login, passwd, expected_result)
```

Cоздайте файл conftest.py

Тут пока можно не создавать класс

И вынесем в него фикстуру `driver`

### Опции браузера

При запуске тестов можно столкнуться с сообщениями со стороны браузера которые будут препятствовать успешному прохождению тестов. Как вариант мы можем блокировать уведомления браузера. Создадим для этого функцию для настройки браузера

Дополним фикстуру опциями браузера:

```python
@pytest.fixture
def driver():
    """Фикстура для инициализации и закрытия драйвера браузера"""
    # Сначала создаем опции браузера
    options = webdriver.ChromeOptions()
    # options.add_argument("--headless") # Без графического интерфейса
    options.add_argument("--ignore-certificate-errors") # Игнорировать ошибки сертификата
    options.add_argument("--window-size=1920,1080") # Задаем разрешение
    options.add_argument("--disable-notifications") # Отключаем уведомления браузера

    # Передаем опции при создании драйвера
    driver = webdriver.Chrome(options=options)

    # Используем get() для открытия страницы
    driver.get(BASE_URL)

    yield driver
    driver.quit()
```
Есть масса других параметров и опций которые Вам могут потребоваться, можете изучить это самостоятельно.

Cоздайте файл config.py

Тут пока можно не создавать класс

Вынесем в него переменные BASE_URL и WAIT_TIMEOUT

Добавьте импорты

```
from config import BASE_URL
```

```
from config import WAIT_TIMEOUT
```
Там где используются эти переменные, self при из вызове не нужен

Убедитесь что тесты запускаются через терминал

## Задание 7: Создание базового класса для работы с Selenium и Allure

Создадим удобные обертки над стандартными функциями Selenium с автоматической интеграцией отчетности Allure.

Создайте файл base_page.py

Импортируем Allure

```python
import allure
```
Если навести курсор на слово allure будет предложено установить пакет, сделайте это

Добавим класс BasePage, это будет базовый класс для функций и методов которые мы будем использовать во всем проекте.

И напишем пару функций которые будут обертками над функциями selenium. 

Начнем с самого нужного - клика по элементам.


```python
# base_page.py
import allure

class BasePage:
    def __init__(self, driver):
        self.driver = driver

    def click(self, selector, text=None):
        element = self.driver.find_element(*selector)
        if text is not None:
            with allure.step(f"Клик по элементу '{text}'"):
                element.click()
                self.get_screenshot()
        else:
            element.click()
            self.get_screenshot()

    def get_screenshot(self):
        allure.attach(
            name="Скриншот",
            body=self.driver.get_screenshot_as_png(),
            attachment_type=allure.attachment_type.PNG,
        )
```

Разберем что мы сделали:

Добавили конструктор, принимающий драйвер. 

```python
    def __init__(self, driver):
        self.driver = driver
```

Конструктор — это специальный метод __init__(), который автоматически вызывается при создании объекта класса.

В нашем случае:

Конструктор принимает один параметр — driver (веб-драйвер Selenium)

Сохраняет этот драйвер в атрибут self.driver

Теперь все методы класса BasePage могут использовать этот драйвер для взаимодействия с браузером

Это немного сложно для понимания, с практикой все станет понятнее. 

Функция get_screenshot делает снимок экрана и передает файл скриншота в allure

В функции click мы принимаем на вход селектор элемента и передаем необязательный текст, используемый для пояснения в allure
1. Находим элемент
2. Если есть текст передаем в allure шаг с текстом - Клик по элементу '{text}'
3. Делаем клик по элементу
4. Делаем скриншот

Таким образом нам не требуется описывать эти шаги каждый раз когда мы хотим сделать клик по элементу, просто используем написанную нами функцию

Теперь нужно перестроить проект чтобы было корректное взаимодействие с вебдрайвером

Обновите LoginPage для наследования от BasePage:

```python
from base_page import BasePage

class LoginPage(BasePage):
```

Это нам позволит использовать функции и методы класса BasePage так будто бы они описаны в LoginPage (через self)

Заменим все клики в функции login

```python
# login_button.click() Заменим старый код
self.click(self.Locators.LOGIN_BUTTON, 'кнопка [Login]')
```

Обратите внимание что наша функция click принимает именно локатор элемента, а не сам элемент

Обновите тесты для передачи драйвера в LoginPage:

```python
page = LoginPage(driver)
```

Создайте файл `requirements.txt` и добавьте в него:

```
pytest~=8.3.4
selenium~=4.27.1
allure-pytest==2.13.5
allure-python-commons~=2.13.5
```

При наведении на содержимое файла будет предложение установить недостающие пакеты, сделайте это.

Запустите выполнение тестов с Allure

```cmd
pytest -m smoke --alluredir=allure-results
```
После прохождения тестов сформируется дирректория которую мы задаем при запуске `allure-results`

Для открытия отчета потребуется установить Allure Framework на устройство. Установим allure2, пакет можно скачать с официального репозитория https://github.com/allure-framework/allure2/releases/tag/2.36.0

Что бы посмотреть отчет выполните команду `allure serve`

Самостоятельно напишите функции set_text, get_text, wait_element по аналогии с click
И перепишите код добавив использование новых функций. 

Обратите внимание что при таком подходе не нужно передавать в функцию login драйвер (driver), уберите его передачу при вызове и из ожидаемых аргументов функции.

Запустите выполнение тестов с Allure. Изучите Allure отчет.

Создайте отдельный файл locators.py, вынесите в него локаторы элементов.

Для того что-бы в allure отчете были шаги 

Добавьте `@allure.step("Текст шага")` перед функцией, или `with allure.step(f"Клик по элементу '{text}'"):` перед фрагментом кода. 

Пример:

```python
    @allure.step("Проверить отображение ошибок при невалидных вариантах пароля")
    def invalid_password(self):
        self.open_change_pass()

        with allure.step("Неверный старый пароль"):
            self.set_text(MainLocators.OLD_PASSWORD_FIELD, 'InValidPass')
            ...
        with allure.step("Попытка установить короткий и простой пароль"):
            self.set_text(MainLocators.OLD_PASSWORD_FIELD, valid_pass)
            ...
    ...
```
В приведенном фрагменте кода есть шаг "Проверить отображение ошибок при невалидных вариантах пароля" внутри которого есть еще два шага "Неверный старый пароль" и "Попытка установить короткий и простой пароль"

<img width="747" height="489" alt="image" src="https://github.com/user-attachments/assets/03914a44-c9f9-4d16-b287-4064e850b99e" />


В результате выполнения задания кода должно было получиться меньше и самое главное он легче читается и воспринимается. А так-же у нас есть Allure отчет с шагами и скриншотами, на основании которого можно понять на каком шаге упал тест.

Шаги на базовые функции на странице login_page избыточны, если уже описаны в base_page.

Шаги не стоит делать на каждое действие, если в этом мало смысла. Текст шага должен быть информативным. В идеале в отчете шаги должны быть как в тест кейсе.

Если функция состоит из одного шага, то лучше использовать @allure.step("Текст шага") перед функцией.

Обратите внимание на логику функции click
- там мы ввели необязательное значение text, в которое передаем название элемента, отчет будет сложно читаемым если в отчете будет selector
- можно добавить в клик степ с locator если text=None
- и аналогичную логику сделать для других базовых функций

```python
    def click(self, selector, text=None):
        element = self.driver.find_element(*selector)
        if text is not None:
            with allure.step(f"Клик по элементу '{text}'"):
                element.click()
                self.get_screenshot()
        else:
            with allure.step(f"Клик по элементу '{selector}'"):
                element.click()
                self.get_screenshot()
```

Что-бы было легче понимать по отчету из-за чего упал тест, добавим get_screenshot() перед закрытием браузера в фикстуру driver в файле conftest.py

```python
@pytest.fixture
def driver():
    driver = webdriver.Chrome()
    driver.get(BASE_URL)
    yield driver
    BasePage(driver).get_screenshot()
    driver.quit()
```
Не забудьте добавить импорт

```python
from base_page import BasePage
```
Теперь в конце каждого теста, вне зависимости от того закончился он успехом или нет, перед закрытием браузера будет делаться скрин последнего состояния. 
Это очень удобно при разборе отчета, для упавших тестов.

## Задание 8: Дебаг + Брейкпоинты в Pycharm — как найти и исправить ошибки в коде

Представьте ситуацию: вы написали тест, запускаете его, а он не работает. В консоли появляется какая-то непонятная ошибка. Что делать?

Как мы делали до этого урока:

1. Смотрели на код и думали "ну почему же не работает?"

2. Пытались угадать, в какой строке ошибка

3. Добавляли print() в разные места, чтобы понять, что происходит

4. Тратили много времени и нервов

Теперь вы научитесь:

1. Останавливать код в любом месте

2. Смотреть, какие значения у переменных в этот момент

3. Шаг за шагом выполнять код и видеть, что происходит

4. Выполнять новый код не перезапуская тесты

5. Находить ошибки и переписывать код значительно быстрее

Основные понятия

Отладка (Debugging) — процесс поиска и устранения ошибок в программном коде.

Брейкпоинт — это красная точка, которую вы ставите в коде. Когда программа доходит до этой точки, она останавливается и ждет ваших команд.

Установка Брейкпоинтов

Инструкция:

- Откройте файл с тестом в PyCharm
- Найдите нужную строку кода
- Щелкните левой кнопкой мыши на левом поле рядом с номером строки
- Появится красная точка — точка останова установлена

Запуск отладки

Через контекстное меню

    Щелкните правой кнопкой мыши на имени тестовой функции

    Выберите «Debug 'test_name'»

Анализ состояния программы

При остановке на точке останова используйте следующие возможности:

Просмотр переменных:

- Окно «Variables» показывает текущие значения всех переменных
- Наведите курсор на переменную в коде для просмотра ее значения

Использование функции Evaluate Expression

Функция Evaluate Expression позволяет выполнять код во время остановки программы в режиме отладки. Это помогает анализировать данные и пробовать изменения без изменения кода тестов.
Это мощный инструмент для интерактивного анализа кода во время отладки. Она позволяет быстро проверять предположения о поведении программы без необходимости добавлять временный код или перезапускать тесты.

## Задание 9: Основы Git и публикация в github

Научимся работать с системой контроля версий Git и опубликуем проект автоматизации тестирования на GitHub. 

Мы будем использовать PyCharm для удобной работы с Git — вам не придется запоминать сложные команды в терминале!

Что такое Git и зачем он нужен?

Представьте, что вы пишете книгу:

Без Git: вы сохраняете файл "моя_книга.docx" и если что-то пошло не так, возвращаться к старой версии сложно

С Git: вы сохраняете каждую главу отдельно, можете вернуться к любой главе, пробовать разные варианты текста

Git — это система контроля версий, которая:

- Сохраняет историю изменений — как "машина времени" для вашего кода

- Защищает от ошибок — если что-то сломалось, можно вернуться к рабочей версии

- Позволяет работать в команде — несколько человек могут работать над одним проектом

- Позволяет хранить код в облаке — ваш проект не пропадет, если сломается компьютер

### Основные понятия Git

Репозиторий (Repository) - Это папка вашего проекта, в которой Git отслеживает все изменения. Бывает:

- Локальный — на вашем компьютере

- Удаленный — на GitHub (в облаке)

Коммит (Commit) - Это "снимок" вашего проекта в определенный момент времени. Каждый коммит имеет:

- Уникальный ID (как серийный номер)

- Автора (ваше имя)

- Дата и время

- Комментарий (что вы изменили)

Ветка (Branch) - Это отдельная линия разработки. Представьте, что вы пишете книгу:

- Ветка master/main — основная книга

- Ветка feature/login-tests — вы пробуете написать новую главу про тесты логина

- Ветка bugfix/fix-screenshots — вы исправляете ошибку в главе про скриншоты

### Основные команды Git

1. add — подготовить файлы к сохранению
Что делает: Добавляет файлы в "зону подготовки". Представьте, что вы собираете вещи в чемодан:

- Берете файл — это add

- Кладет в чемодан — файл готов к коммиту

- Еще не положили в чемодан — Git не знает об этом файле

Как сделать в PyCharm:

- Откройте вкладку "Commit" в левом нижнем углу (или нажмите Alt+0, если на русской раскладке Alt+ё)

- Вы увидите все измененные файлы

- Поставьте галочки напротив файлов, которые хотите добавить

- Или нажмите кнопку "Add" над списком файлов

Пример из жизни: Вы написали новый тест в файле test_login.py. Чтобы Git узнал об этом файле, нужно его добавить командой add.

2. commit — сохранить изменения

Что делает: Сохраняет текущее состояние файлов в истории Git. Это как сделать фотографию вашего проекта в данный момент.

Как сделать в PyCharm:

1. В той же вкладке "Commit" напишите понятное сообщение

- Пример хорошего сообщения: "Добавил тест для проверки логина с неверным паролем"

- Пример плохого сообщения: "фиксы" или "исправления" (непонятно, что исправлено)

2. Нажмите кнопку "Commit"

Важные правила для коммитов:

- Один коммит = одно логическое изменение

- Сообщение должно отвечать на вопрос: "Что сделано и зачем?"

Делайте коммиты часто. Коммиты не должны быть привязаны ко времени. Не надо, безусловно, коммитить отдельно каждую функцию. Но, если выбирать между этим и заливкой всех изменений одним коммитом, то лучше первое. 

Примеры из жизни:

- Написали несколько новых тестов по новому функционалу, проверили что тесты работают, сделали коммит.

- Изменились локаторы и логика - внесли требуемые изменения в проект, проверили все тесты которые могло затронуть, сделали коммит.

3. push — отправить изменения на GitHub

Что делает: Загружает ваши коммиты с компьютера на GitHub (в облако). Это как отправить письмо по почте.

Как сделать в PyCharm:

1. Нажмите на синюю стрелку вверх в правом верхнем углу PyCharm

2. Или меню "VCS" → "Git" → "Push"

3. Появится окно — нажмите "Push"

Почему это важно:

- Резервная копия — ваш код сохраняется не только на компьютере

- Совместная работа — другие могут видеть ваш код

- Портфолио — вы можете показать работодателю ваши проекты

4. checkout — переключиться между ветками

Что делает: Позволяет переключиться на другую ветку проекта.

Как сделать в PyCharm:

1. В правом нижнем углу PyCharm нажмите на название текущей ветки (обычно "main" или "master")

2. Выберите "New Branch" чтобы создать новую ветку Или выберите другую ветку чтобы переключиться на нее

3. Чтобы увидеть все ветки, выберите "Remote Branches"

Пример использования:

- Вы хотите добавить новую фичу, но боитесь сломать рабочий код

- Создаете новую ветку add-new-tests

- Работаете в ней

- Когда все готово, сливаете с основной веткой

5. merge — объединить изменения

Что делает: Сливает изменения из одной ветки в другую. Это как склеить две версии документа.

Как сделать в PyCharm:

1. Переключитесь в ветку, КУДА хотите добавить изменения (обычно "main")

2. В правом нижнем углу нажмите на название ветки

3. Выберите "Merge..."

4. Выберите ветку, ИЗ которой хотите взять изменения

5. Нажмите "Merge"

Что происходит:

- Git пытается автоматически объединить изменения

- Если изменения в одних и тех же строках — будет "конфликт"

PyCharm поможет разрешить конфликты визуально

### Практическая часть: публикуем проект на GitHub

Шаг 1: Создаем локальный репозиторий Git

Откройте ваш проект в PyCharm

В меню выберите "VCS" → "Enable Version Control Integration..."

В появившемся окне выберите "Git"

Нажмите "OK"

Что произошло: PyCharm создал скрытую папку .git в вашем проекте. Теперь Git отслеживает все изменения.

Шаг 2: Добавляем файлы в Git

В левом нижнем углу PyCharm найдите вкладку "Commit"

Вы увидите все файлы, которые Git еще не знает (они будут красного цвета)

Нажмите кнопку "Add" над списком файлов

Все файлы станут зелеными — теперь Git знает о них

Шаг 3: Делаем первый коммит

В поле "Commit Message" напишите: "Первоначальная настройка проекта"

Нажмите кнопку "Commit"

Поздравляю! Вы сделали первый коммит

Шаг 4: Создаем репозиторий на GitHub

Откройте сайт github.com

Нажмите значок "+" в правом верхнем углу

Выберите "New repository"

Заполните форму:

Repository name: selenium-course (название вашего проекта)

Description: Курс по автоматизации тестирования (описание)

Выберите "Public" (публичный — все увидят) или "Private" (только вы)

Не ставьте галочки на "Initialize this repository with..." — мы уже создали файлы

Нажмите "Create repository"

Шаг 5: Подключаем PyCharm к GitHub

Скопируйте URL вашего репозитория с GitHub (кнопка "Code" → HTTPS)

В PyCharm выберите "VCS" → "Git" → "Remotes..."

Нажмите "+"

В поле "Name" введите: origin

В поле "URL" вставьте скопированный адрес

Нажмите "OK"

Шаг 6: Отправляем проект на GitHub
Нажмите на синюю стрелку вверх в правом верхнем углу PyCharm

В появившемся окне нажмите "Push"

Если все хорошо, появится сообщение об успешной отправке

Шаг 7: Проверяем результат

Вернитесь на GitHub в ваш репозиторий

Обновите страницу

Вы должны увидеть все файлы вашего проекта!

### Советы для новичков

Что коммитить, а что нет:
✅ Коммитим:

1. Файлы с кодом (.py)
2. Конфигурационные файлы (.gitignore, requirements.txt)
3. Документацию (.md файлы)

❌ Не коммитим:

1. Пароли и ключи (.env файлы)
2. Временные файлы (pycache/)
3. Файлы с зависимостями (venv/)
4. Результаты тестов (allure-results/)

### Как настроить .gitignore:

В корне проекта создайте файл .gitignore

Добавьте в него:

```text
# Папки Python
__pycache__/
*.pyc

# Виртуальное окружение
venv/

# Файлы окружения с паролями
.env
.secrets

# Результаты тестов
allure-results/
allure-report/

# Файлы операционной системы
.DS_Store
Thumbs.db
```
