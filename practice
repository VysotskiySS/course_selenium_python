# Практические задания

## Задание 1: Простой тест авторизации

Выполнить задание ниже используя теорию "Основные методы Selenium WebDriver в Python"
Весь код пока пишем одним файлом, без классов, функций, фикстур, просто дописать шаблон
Для написания локаторов в целях обучения попробовать разные методы, By.ID, By.XPATH и т.п.

1. Установить браузер chrome (обычный, вебдрайвер селениум сам подтянет)
2. Установить pycharm, создать проект, создать файл py, вставить в файл шаблон решения
3. Установить selenium через пкм в IDE на строках импорта (from selenium import webdriver)
4. Комментарии "# 1." оставляем, требуемый код дописываем ниже каждого комментария
5. Для проверки текста использовать assert. Есть ньюанс с проверкой текста, добиться именно успешного прохождения, считаем что не баг, а особенность.

Практическое задание

Задача: Автоматизировать сценарий:

1. Открыть https://the-internet.herokuapp.com/login
2. Ввести логин tomsmith и пароль SuperSecretPassword!
3. Нажать Login
4. Дождаться сообщения "You logged into a secure area!"
5. Нажать Logout

Шаблон решения:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome()
try:
    driver.get("https://the-internet.herokuapp.com/login")
    
    # Ваш код здесь
    # 1. Найти поля ввода и кнопку
    # 2. Ввести учетные данные
    # 3. Кликнуть Login
    # 4. Ожидать появления flash-сообщения (id="flash")
    # 5. Проверить текст сообщения
    # 6. Найти и нажать Logout
    
finally:
    driver.quit()
```

Задание 2: 

Добавим в начало файла

import pytest

вынесем написанный нами код (все кроме импортов) в функцию и добавим класс

Важно!

Имена тестовых классов - Должны начинаться с Test (с большой буквы)
Имена тестовых функций - Должны начинаться с test_

в результате должно получиться так:

```python
class TestLoginPage:


    def test_login(self):
        driver = webdriver.Chrome()
        try:
# остальной код без изменений не считая отступов
```

Написать по аналогии второй тест, пока отдельной функцией def test_login_invalid(self):
Тест на ввод неправильного логина с проверкой сообщения "Your username is invalid!"

Задание 3:

Теперь наглядно видно что большая часть кода дублируется, уйти от этого нам поможет параметризация

Следующий шаг обьединить эти два теста в один

Доработаем тест test_login

1. Добавить в функцию на вход три параметра 

```
def "test_login(self, login, password, expected_result):"
```

через expected_result мы будем определять что мы ожидаем - сообщение об успехе или ошибку

2. Изменить в "2. Ввести учетные данные" ввод не конкретных значений а переменные login, password
3. Добавить перед обьявлением функции параметризацию

    @pytest.mark.parametrize("login, password, expected_result",
        [
            ("tomsmith", "SuperSecretPassword!", True), # Валидные данные
            (), # Неправильный пароль
        ]
    )

тут сначало мы обозначаем какие переменные мы будем передавать ("login, password, expected_result",), а потом перечисляем конкретные значения этих переменных ("tomsmith", "SuperSecretPassword!", True)

рассмотрим только эти два кейса
1. Валидные данные
2. Неправильный логин
тут есть еще вариант с неправильным паролем и правильным логином, но на нормальных ресурсах не делают отдельное сообщение для таких ситуаций и для этого нужно немного менять подход к параметризации. 

Что бы выполнять один из двух assert'ов можно использовать "if expected_result:" более наглядно это можно представить как "if expected_result == True" просто более правильное и лаконичное написание

Не забудте учесть что кнопки Logout без успешной авторизации не будет
